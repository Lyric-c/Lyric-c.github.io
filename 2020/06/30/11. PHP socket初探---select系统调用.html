<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>11. PHP socket初探---select系统调用 | APTX4869</title><meta name="description" content="socket初探 — 先从一个简单的socket服务器开始＞中依次讲解了三个逐渐进步的服务器：  只能服务于一个客户端的服务器 利用fork可以服务于多个客户端的额服务器 利用预fork派生进程服务于多个客户端的服务器  最后一种服务器的进程模型基本上的大概原理其实跟我们常用的apache是非常相似的．其实这种模型最大的问题在于需要根据实际业务预估进程数量，依旧是需要大量进程来解决问题，可能会出现"><meta name="author" content="Irelia"><meta name="copyright" content="Irelia"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="11. PHP socket初探---select系统调用"><meta name="twitter:description" content="socket初探 — 先从一个简单的socket服务器开始＞中依次讲解了三个逐渐进步的服务器：  只能服务于一个客户端的服务器 利用fork可以服务于多个客户端的额服务器 利用预fork派生进程服务于多个客户端的服务器  最后一种服务器的进程模型基本上的大概原理其实跟我们常用的apache是非常相似的．其实这种模型最大的问题在于需要根据实际业务预估进程数量，依旧是需要大量进程来解决问题，可能会出现"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="11. PHP socket初探---select系统调用"><meta property="og:url" content="https://seesaw.fun/2020/06/30/11.%20PHP%20socket%E5%88%9D%E6%8E%A2---select%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html"><meta property="og:site_name" content="APTX4869"><meta property="og:description" content="socket初探 — 先从一个简单的socket服务器开始＞中依次讲解了三个逐渐进步的服务器：  只能服务于一个客户端的服务器 利用fork可以服务于多个客户端的额服务器 利用预fork派生进程服务于多个客户端的服务器  最后一种服务器的进程模型基本上的大概原理其实跟我们常用的apache是非常相似的．其实这种模型最大的问题在于需要根据实际业务预估进程数量，依旧是需要大量进程来解决问题，可能会出现"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-06-30T08:33:11.720Z"><meta property="article:modified_time" content="2020-06-30T08:33:11.720Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://seesaw.fun/2020/06/30/11.%20PHP%20socket%E5%88%9D%E6%8E%A2---select%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html"><link rel="prev" title="10. PHP socket初探---关于IO的一些枯燥理论" href="https://seesaw.fun/2020/06/30/10.%20PHP%20socket%E5%88%9D%E6%8E%A2---%E5%85%B3%E4%BA%8EIO%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9E%AF%E7%87%A5%E7%90%86%E8%AE%BA.html"><link rel="next" title="16. swoole的协程是个什么鬼" href="https://seesaw.fun/2020/06/30/16.%20swoole%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: false  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">APTX4869</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">11. PHP socket初探---select系统调用</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-06-30 08:33:11"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-06-30</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-06-30 08:33:11"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-06-30</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><a href="https://t.ti-node.com/thread/6445811931457519616" target="_blank" rel="noopener" title="PHP socket初探 --- 先从一个简单的socket服务器开始">socket初探 — 先从一个简单的socket服务器开始</a>＞中依次讲解了三个逐渐进步的服务器：</p>
<ul>
<li>只能服务于一个客户端的服务器</li>
<li>利用fork可以服务于多个客户端的额服务器</li>
<li>利用预fork派生进程服务于多个客户端的服务器</li>
</ul>
<p>最后一种服务器的进程模型基本上的大概原理其实跟我们常用的apache是非常相似的．<br>其实这种模型最大的问题在于需要根据实际业务预估进程数量，依旧是需要大量进程来解决问题，可能会出现CPU浪费在进程间切换上，还有可能会出现惊群现象（简单理解就是100个进程在等带客户端连接，来了一个客户端但是所有进程都被唤醒了，但最终只有一个进程为这个客户端服务，其余99个白白折腾），那么，有没有一种解决方案可以使得少量进程服务于多个客户端呢？<br>答案就是在＜<a href="https://t.ti-node.com/thread/6445811931549794305" target="_blank" rel="noopener" title="PHP socket初探 --- 关于IO的一些枯燥理论">PHP socket初探 — 关于IO的一些枯燥理论</a>＞中提到的＂IO多路复用＂．多路是指多个客户端连接socket，复用就是指复用少数几个进程，多路复用本身依然隶属于同步通信方式，只是表现出的结果看起来像异步，这点值得注意．目前多路复用有三种常用的方案，依次是：</p>
<ul>
<li>select，最早的解决方案</li>
<li>poll，算是select的升级版</li>
<li>epoll，目前的最终解决版，解决c10k问题的功臣</li>
</ul>
<p>今天说的是select，这个东西本身是个Linux系统调用．在Linux中一切皆为文件，socket也不例外，每当Linux打开一个文件系统都会返回一个对应该文件的标记叫做文件描述符．文件描述符是一个非负整数，当文件描述数达到最大的时候，会重新回到小数重新开始（题外话：按照传统，一般情况下标准输入是0，标准输出是1，标准错误是2）．对文件的读写操作就是利用对文件描述符的读写操作．一个进程可以操作的文件描述符的数量是有限制的，不同系统有不同的数量，在linux中，可以通过调整ulimit来调整控制．<br>先通过一个简单的例子说明下select的作用和功能．双11到了，你给少林足球队买了很多很多球鞋，分别有10个快递给你运送，然后你就不断地电话询问这10个快递员，你觉得有点儿累．阿梅很心疼你，于是阿梅就说：”这事儿你不用管了，你去专心练大力金刚腿吧，等任何一个快递到了，我告诉你”．当其中一个快递来了后，阿梅就喊你：＂下来啦，有快递！＂，但是，这个阿梅比较缺心眼，她不告诉你是具体哪双鞋子的快递，只告诉你有快递到了．所以，你只能依次查询一遍所有快递单的状态才能确认是哪个签收了．<br>上面这个例子通过结合术语演绎一遍就是，你就是服务器软件，阿梅就是select，10个快递就是10个客户端（也就是10个连接socket fd）．阿梅负责替你管理着这10个连接socket fd，当其中任何一个fd有反应了也就是可以读数据或可以发送数据了，阿梅（select）就会告诉你有可以读写的fd了，但是阿梅（select）不会告诉你是哪个fd可读写，所以你必须轮循所有fd来看看是哪个fd，是可读还是可写．<br>是时候机械记忆一波儿了：<br>当你启动select后，需要将三组不同的socket fd加入到作为select的参数，传统意义上这种fd的集合就叫做fd_set，三组fd_set依次是可读集合，可写集合，异常集合．三组fd_set由系统内核来维护，每当select监控管理的三个fd_set中有可读或者可写或者异常出现的时候，就会通知调用方．调用方调用select后，调用方就会被select阻塞，等待可读可写等事件的发生．一旦有了可读可写或者异常发生，需要将三个fd_set从内核态全部copy到用户态中，然后调用方通过轮询的方式遍历所有fd，从中取出可读可写或者异常的fd并作出相应操作．如果某次调用方没有理会某个可操作的fd，那么下一次其余fd可操作时，也会再次将上次调用方未处理的fd继续返回给调用方，也就是说去遍历fd的时候，未理会的fd依然是可读可写等状态，一直到调用方理会．<br>上面都是我个人的理解和汇总，有错误可以指出，希望不会误人子弟．下面通过php代码实例来操作一波儿select系统调用．在php中，你可以通过stream_select或者socket_select来操作select系统调用，下面演示socket_select进行代码演示：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BEGIN 创建一个tcp socket服务器</span></span><br><span class="line">$host = <span class="string">'0.0.0.0'</span>;</span><br><span class="line">$port = <span class="number">9999</span>;</span><br><span class="line">$listen_socket = socket_create( AF_INET, SOCK_STREAM, SOL_TCP );</span><br><span class="line">socket_bind( $listen_socket, $host, $port );</span><br><span class="line">socket_listen( $listen_socket );</span><br><span class="line"><span class="comment">// END 创建服务器完毕 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也将监听socket放入到read fd set中去，因为select也要监听listen_socket上发生事件</span></span><br><span class="line">$client = [ $listen_socket ];</span><br><span class="line"><span class="comment">// 先暂时只引入读事件，避免有同学晕头</span></span><br><span class="line">$write = [];</span><br><span class="line">$exp = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始进入循环</span></span><br><span class="line"><span class="keyword">while</span>( <span class="keyword">true</span> )&#123;</span><br><span class="line">  $read = $client;</span><br><span class="line">  <span class="comment">// 当select监听到了fd变化，注意第四个参数为null</span></span><br><span class="line">  <span class="comment">// 如果写成大于0的整数那么表示将在规定时间内超时</span></span><br><span class="line">  <span class="comment">// 如果写成等于0的整数那么表示不断调用select，执行后立马返回，然后继续</span></span><br><span class="line">  <span class="comment">// 如果写成null，那么表示select会阻塞一直到监听发生变化</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  第一个参数必须是数组,数组里面含有待检测的套接字,而且第四个参数写成null阻塞就是代表程序就一直停在socket_select这个函数上,</span></span><br><span class="line"><span class="comment">  什么都不干,等你有连接或者有数据发送,我才继续执行,所以你使用var_dump后,再进行telnet 才会有返回值,否则没有任何输出的</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span>( socket_select( $read, $write, $exp, <span class="keyword">null</span> ) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="comment">// 判断listen_socket有没有发生变化，如果有就是有客户端发生连接操作了</span></span><br><span class="line">    <span class="keyword">if</span>( in_array( $listen_socket, $read ) )&#123;</span><br><span class="line">	  <span class="comment">// 将客户端socket加入到client数组中</span></span><br><span class="line">	  <span class="comment">//socket_accept创建一个可用套接字传送数据,准备给其他客户端发送数据用的</span></span><br><span class="line">	  $client_socket = socket_accept( $listen_socket );</span><br><span class="line">	  <span class="comment">//下面这句很有用,避免了  unset( $read[ $key ] )后,在while时,客户端进来再次用  $client赋值给$read</span></span><br><span class="line">	  $client[] = $client_socket;</span><br><span class="line">	  <span class="comment">// 然后将listen_socket从read中去除掉</span></span><br><span class="line">	  $key = array_search( $listen_socket, $read );</span><br><span class="line">	  <span class="keyword">unset</span>( $read[ $key ] );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查看去除listen_socket中是否还有client_socket</span></span><br><span class="line">	<span class="comment">//已经进行telnet连接后,会直接走这一步,不会进去上面代码的in_array,</span></span><br><span class="line">	<span class="keyword">if</span>( count( $read ) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">	  $msg = <span class="string">'hello world'</span>;</span><br><span class="line">	  <span class="keyword">foreach</span>( $read <span class="keyword">as</span> $socket_item )&#123;</span><br><span class="line">      <span class="comment">// 从可读取的fd中读取出来数据内容，然后发送给其他客户端</span></span><br><span class="line">      $content = socket_read( $socket_item, <span class="number">2048</span> );</span><br><span class="line">      <span class="comment">// 循环client数组，将内容发送给其余所有客户端</span></span><br><span class="line">      <span class="keyword">foreach</span>( $client <span class="keyword">as</span> $client_socket )&#123;</span><br><span class="line">        <span class="comment">// 因为client数组中包含了 listen_socket 以及当前发送者自己socket，$client_socket != $socket_item 再次排除自已,所以需要排除二者</span></span><br><span class="line">        <span class="keyword">if</span>( $client_socket != $listen_socket &amp;&amp; $client_socket != $socket_item )&#123;</span><br><span class="line">          socket_write( $client_socket, $content, strlen( $content ) );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 当select没有监听到可操作fd的时候，直接continue进入下一次循环</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将文件保存为server.php，然后执行php server.php运行服务，同时再打开三个终端，执行telnet 127.0.0.1 9999，然后在任何一个telnet终端中输入”I am xiaoming!”，再看其他两个telnet窗口，是不是感觉很屌？<br>不完全截图图下：<br><img src="http://static.ti-node.com/6389738812670476289" alt=""><br>还没意识到问题吗？如果我们看到有三个telnet客户端连接服务器并且可以彼此之间发送消息，但是我们只用了一个进程就可以服务三个客户端，如果你愿意，可以开更多的telnet，但是服务器只需要一个进程就可以搞定，这就是IO多路复用diao的地方！<br>最后，我们重点解析一些socket_select函数，我们看下这个函数的原型：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket_select ( <span class="keyword">array</span> &amp;$read , <span class="keyword">array</span> &amp;$write , <span class="keyword">array</span> &amp;$except , int $tv_sec [, int $tv_usec = <span class="number">0</span> ] )</span><br></pre></td></tr></table></figure>
<p>值得注意的是$read，$write，$except三个参数前面都有一个&amp;，也就是说这三个参数是引用类型的，是可以被改写内容的．在上面代码案例中，服务器代码第一次执行的时候，我们要把需要监听的所有fd全部放到了read数组中，然而在当系统经历了select后，这个数组的内容就会发生改变，由原来的全部read fds变成了只包含可读的read fds，这也就是为什么声明了一个client数组，然后又声明了一个read数组，然后read = client．如果我们直接将client当作socket_select的参数，那么client数组内容就被修改．假如有5个用户保存在client数组中，只有1个可读，在经过socket_select后client中就只剩下那个可读的fd了，其余4个客户端将会丢失，此时客户端的表现就是连接莫名其妙发生丢失了．</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Irelia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://seesaw.fun/2020/06/30/11.%20PHP%20socket%E5%88%9D%E6%8E%A2---select%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html">https://seesaw.fun/2020/06/30/11.%20PHP%20socket%E5%88%9D%E6%8E%A2---select%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/30/10.%20PHP%20socket%E5%88%9D%E6%8E%A2---%E5%85%B3%E4%BA%8EIO%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9E%AF%E7%87%A5%E7%90%86%E8%AE%BA.html"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">10. PHP socket初探---关于IO的一些枯燥理论</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/30/16.%20swoole%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC.html"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">16. swoole的协程是个什么鬼</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Irelia</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>